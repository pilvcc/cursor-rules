---
alwaysApply: true
---

Minimize abstractions. Every abstraction has a cost: indirection, cognitive
overhead, and code that exists only to manage other code. Only add abstractions
when the benefit (usually deduplication) clearly outweighs this cost.

Anti-patterns to avoid:

- Layers of indirection (A calls B calls C when A could just do C's work)
- Wrapper types/classes that add no behavior
- "Clean architecture" patterns that multiply files and interfaces
- Config/options objects for things that could be hardcoded
- Premature generalization ("this might need to support X later")
- "Helper" functions called only once
- Breaking a function into "steps" as separate functions
- Wrapper functions that just call another function with minor tweaks

NEVER extract a function/method/helper that is only called once. Inline it at
the call site, regardless of length. Extract only when used 2+ times. Length and
complexity are not valid reasons to extract - only reuse is.

When designing, ask: "What's the least amount of abstraction needed for this to
work?" Start there and stay there. Add abstraction only when duplication or
genuine complexity forces it.

Resist aesthetic refactoring. Developers often create abstractions not because
they're needed, but because they satisfy an itch:

- "This function is getting long" — length alone is not a problem
- "These lines feel like they belong together" — group them with a comment
- "This deserves a nice name" — naming doesn't justify extracting
- "The parent function will look cleaner" — hiding code isn't simplifying it
- "This pattern should have a proper API" — not everything needs to be an API

These urges produce code that looks organized but is actually harder to follow.
A 100-line function you can read top-to-bottom is simpler than 5 functions you
have to jump between. Resist the itch. If you encounter itch-scratch
abstractions, inline them.
