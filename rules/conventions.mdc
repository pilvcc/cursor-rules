---
alwaysApply: true
---

Follow these conventions:

- Use radash as the standard utility library. Prefer radash functions over
  manual implementations (e.g. `sum()`, not `.reduce(...)`). Skip only if it
  makes the code much more awkward.

- In particular, use radash's `map` instead of `Promise.all(items.map(...))`.

- Use `cn()` for conditional classNames. No template literals with conditionals.

- Use TanStack `useMutation` for async actions. No useState for loading state,
  no manual try/catch.

- Use Tailwind unless React Native doesn't support it (shadow, gradients,
  percentage dimensions, zIndex, aspectRatio, calculated values). Inline styles
  when needed--no StyleSheet. LinearGradient requires styles.

- No inline JSX comments. No comments restating what code obviously does. Only
  comment non-obvious reasoning.

- Use icons from centralicons.

- Name the main component's props type `Props`. Secondary components use
  `ComponentNameProps`.

- Don't specify function return types. Let TypeScript infer them.

- Import globals (db, API clients) directly. Never pass them as parameters.

- Use anaphoric `it` in short single-param lambdas:
  `animals.map((it) => it.size)`, not `animals.map((animal) => animal.size)`. If
  the whole lambda can be read conceptually as a single unit -- e.g. "returns
  the size sof whatever it's given" -- use `it`. For larger, more complex
  lambdas where you reference the object repeatedly, descriptive names are fine.
